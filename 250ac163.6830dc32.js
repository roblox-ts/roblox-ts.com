(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{73:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"metadata",(function(){return s})),t.d(n,"toc",(function(){return l})),t.d(n,"default",(function(){return b}));var a=t(3),r=t(7),c=(t(0),t(93)),i={id:"roblox-api",title:"Roblox API"},s={unversionedId:"api/roblox-api",id:"api/roblox-api",isDocsHomePage:!1,title:"Roblox API",description:"roblox-ts provides typings for the Roblox API which are partially handwritten and partially automatically generated.",source:"@site/docs/api/roblox-api.mdx",slug:"/api/roblox-api",permalink:"/docs/api/roblox-api",editUrl:"https://github.com/roblox-ts/roblox-ts.github.io/blob/master/docs/api/roblox-api.mdx",version:"current",sidebar:"docs",previous:{title:"Setup Guide",permalink:"/docs/setup-guide"},next:{title:"Identifiers",permalink:"/docs/api/identifiers"}},l=[{value:"Values",id:"values",children:[{value:"Globals",id:"globals",children:[]},{value:"Constructors",id:"constructors",children:[]},{value:"nil",id:"nil",children:[]}]},{value:"Types",id:"types",children:[{value:"Provided Types",id:"provided-types",children:[]},{value:"RemoteEvent Types",id:"remoteevent-types",children:[]},{value:"Exceptions",id:"exceptions",children:[]}]},{value:"Utility Interfaces",id:"utility-interfaces",children:[{value:"Services",id:"services",children:[]},{value:"CreatableInstances",id:"creatableinstances",children:[]},{value:"AbstractInstances",id:"abstractinstances",children:[]},{value:"Instances",id:"instances",children:[]},{value:"Usage with Generics",id:"usage-with-generics",children:[]}]}],o={toc:l};function b(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(c.b)("wrapper",Object(a.a)({},o,t,{components:n,mdxType:"MDXLayout"}),Object(c.b)("p",null,"roblox-ts provides typings for the Roblox API which are partially handwritten and partially automatically generated."),Object(c.b)("p",null,"In general, everything from the Roblox API is available for use, unless it is deprecated or conflicts with TypeScript."),Object(c.b)("h2",{id:"values"},"Values"),Object(c.b)("h3",{id:"globals"},"Globals"),Object(c.b)("p",null,"All global values from the Roblox API are present in roblox-ts typings."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'print("Hello World!");\n')),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const zero = math.sin(math.pi);\n")),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'coroutine.wrap(() => {\n    print("A");\n    wait(1);\n    print("B");\n})();\n')),Object(c.b)("h3",{id:"constructors"},"Constructors"),Object(c.b)("p",null,Object(c.b)("inlineCode",{parentName:"p"},".new()")," functions (like ",Object(c.b)("inlineCode",{parentName:"p"},"Vector3.new()")," or ",Object(c.b)("inlineCode",{parentName:"p"},"CFrame.new()"),") should instead be called with the ",Object(c.b)("inlineCode",{parentName:"p"},"new")," operator. ",Object(c.b)("inlineCode",{parentName:"p"},"new T(...)")," will always compile to ",Object(c.b)("inlineCode",{parentName:"p"},"T.new(...)"),"."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const v3 = new Vector3(1, 2, 3); // compiles to Vector3.new(1, 2, 3)\nprint(v3.X, v3.Y, v3.Z); // 1 2 3\n")),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'const part = new Instance("Part");\nprint(part.Color);\n')),Object(c.b)("h3",{id:"nil"},"nil"),Object(c.b)("p",null,Object(c.b)("inlineCode",{parentName:"p"},"undefined")," is a direct replacement for ",Object(c.b)("inlineCode",{parentName:"p"},"nil"),". It can be used both as a type and a value."),Object(c.b)("h2",{id:"types"},"Types"),Object(c.b)("h3",{id:"provided-types"},"Provided Types"),Object(c.b)("p",null,"Every Roblox class (",Object(c.b)("inlineCode",{parentName:"p"},"Instance"),", ",Object(c.b)("inlineCode",{parentName:"p"},"Part"),", ",Object(c.b)("inlineCode",{parentName:"p"},"Humanoid"),", ",Object(c.b)("inlineCode",{parentName:"p"},"Workspace"),", etc.) is provided as a global/ambient type. You can use these types to describe variables, function parameters, function return types, and just about anything else in your code."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'let part: Part | undefined;\npart = new Instance("Part");\nprint(part.Size);\n')),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'function takesBasePart(basePart: BasePart) {\n    return basePart.Size.X + basePart.Size.Y + basePart.Size.Z;\n}\n\n// we can use any type which inherits from BasePart!\ntakesBasePart(new Instance("Seat"));\ntakesBasePart(new Instance("Part"));\ntakesBasePart(new Instance("WedgePart"));\n\n// Humanoid does not inherit from BasePart, so this will error!\n// takesBasePart(new Instance("Humanoid"));\n')),Object(c.b)("h3",{id:"remoteevent-types"},"RemoteEvent Types"),Object(c.b)("p",null,"New roblox-ts users are usually confused why ",Object(c.b)("inlineCode",{parentName:"p"},"RemoteEvent.OnServerEvent")," only allows ",Object(c.b)("inlineCode",{parentName:"p"},"unknown")," arguments."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'const remoteEvent = new Instance("RemoteEvent");\n\n// this works fine\nremoteEvent.OnClientEvent.Connect((points: number) => {});\n\n// changing unknown to number causes an error!\nremoteEvent.OnServerEvent.Connect((player: Player, points: unknown) => {});\n')),Object(c.b)("p",null,"The reason for this is because client-to-server networking ",Object(c.b)("em",{parentName:"p"},"cannot")," be trusted. Exploiters or cheaters in your game can fire your RemoteEvent functions with whatever data they want."),Object(c.b)("p",null,"If your code is expecting ",Object(c.b)("inlineCode",{parentName:"p"},"points")," to be a ",Object(c.b)("inlineCode",{parentName:"p"},"number"),", but the client sends a ",Object(c.b)("inlineCode",{parentName:"p"},"nil")," value, the server will error. By sending a large number of requests very quickly which result in errors, an exploiter could crash your game server and disconnect all of your players."),Object(c.b)("p",null,"Instead, you should assume your inputs can be any possible value. You can verify the arguments with a type validation package like ",Object(c.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.npmjs.com/package/@rbxts/t"}),Object(c.b)("inlineCode",{parentName:"a"},"@rbxts/t")),"."),Object(c.b)("p",null,"Alternatively, the community has created a few networking libraries which make the experience much nicer!"),Object(c.b)("ul",null,Object(c.b)("li",{parentName:"ul"},Object(c.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.npmjs.com/package/@rbxts/net"}),"@rbxts/net")),Object(c.b)("li",{parentName:"ul"},Object(c.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.npmjs.com/package/@rbxts/networked-signals"}),"@rbxts/networked-signals")),Object(c.b)("li",{parentName:"ul"},Object(c.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.npmjs.com/package/@rbxts/simplesignals"}),"@rbxts/simplesignals"))),Object(c.b)("h3",{id:"exceptions"},"Exceptions"),Object(c.b)("p",null,"Deprecated types are usually not provided. Exceptions to this rule are made for API members which do not have a non-deprecated functional equivalent."),Object(c.b)("p",null,"One notable exception: ",Object(c.b)("inlineCode",{parentName:"p"},"Instance.Changed")," is not provided as it conflicts with inheritance. Usually, you want to use ",Object(c.b)("inlineCode",{parentName:"p"},"Instance.GetPropertyChangedSignal()")," instead."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { Workspace } from "@rbxts/services";\nWorkspace.GetPropertyChangedSignal("DistributedGameTime").Connect(() => {\n    print(Workspace.DistributedGameTime);\n});\n')),Object(c.b)("p",null,"If you ",Object(c.b)("em",{parentName:"p"},"must")," use ",Object(c.b)("inlineCode",{parentName:"p"},"Instance.Changed"),", you can workaround this by asserting an intersection type with ",Object(c.b)("inlineCode",{parentName:"p"},"ChangedSignal"),":"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"function foo(part: Part) {\n    (part as Part & ChangedSignal).Changed.Connect(name => {})\n}\n")),Object(c.b)("h2",{id:"utility-interfaces"},"Utility Interfaces"),Object(c.b)("p",null,"There are a few key global interfaces which make manipulating types easier:"),Object(c.b)("h3",{id:"services"},"Services"),Object(c.b)("p",null,Object(c.b)("inlineCode",{parentName:"p"},"Services")," is an interface consisting of a mapping of string name to type for every Roblox service which you can fetch with ",Object(c.b)("inlineCode",{parentName:"p"},'game:GetService("ServiceName")'),"."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"interface Services {\n    AnalyticsService: AnalyticsService;\n    AppUpdateService: AppUpdateService;\n    AssetCounterService: AssetCounterService;\n    AssetDeliveryProxy: AssetDeliveryProxy;\n    // ... many more services!\n}\n")),Object(c.b)("p",null,"You can get a union of all service names with ",Object(c.b)("inlineCode",{parentName:"p"},"keyof Services"),".\nAnd you can get a union of all service types with ",Object(c.b)("inlineCode",{parentName:"p"},"Services[keyof Services]"),"."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"type AllServiceNames = keyof Services;\ntype AllServices = Services[keyof Services];\n")),Object(c.b)("h3",{id:"creatableinstances"},"CreatableInstances"),Object(c.b)("p",null,Object(c.b)("inlineCode",{parentName:"p"},"CreatableInstances")," is an interface consisting of a mapping of string name to type for every Roblox instance which can be created with ",Object(c.b)("inlineCode",{parentName:"p"},'Instance.new("ClassName")'),"."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"interface CreatableInstances {\n    Accessory: Accessory;\n    Accoutrement: Accoutrement;\n    Actor: Actor;\n    AlignOrientation: AlignOrientation;\n    // ... many more instances!\n}\n")),Object(c.b)("p",null,"You can get a union of all creatable instance names with ",Object(c.b)("inlineCode",{parentName:"p"},"keyof CreatableInstances"),".\nAnd you can get a union of all creatable instance types with ",Object(c.b)("inlineCode",{parentName:"p"},"CreatableInstances[keyof CreatableInstances]"),"."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"type AllCreatableInstanceNames = keyof CreatableInstances;\ntype AllCreatableInstances = CreatableInstances[keyof CreatableInstances];\n")),Object(c.b)("h3",{id:"abstractinstances"},"AbstractInstances"),Object(c.b)("p",null,Object(c.b)("inlineCode",{parentName:"p"},"AbstractInstances")," is an interface consisting of a mapping of string name to type for every Roblox instance which will ",Object(c.b)("em",{parentName:"p"},"never")," be created. Generally, these are useful for functions that check inheritance like ",Object(c.b)("inlineCode",{parentName:"p"},'Instance:IsA("ClassName")'),"."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"interface AbstractInstances {\n    BackpackItem: BackpackItem;\n    BasePart: BasePart;\n    BasePlayerGui: BasePlayerGui;\n    BaseScript: BaseScript;\n    // ... many more instances!\n}\n")),Object(c.b)("p",null,"You can get a union of all abstract instance names with ",Object(c.b)("inlineCode",{parentName:"p"},"keyof AbstractInstances"),".\nAnd you can get a union of all abstract instance types with ",Object(c.b)("inlineCode",{parentName:"p"},"AbstractInstances[keyof AbstractInstances]"),"."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"type AllAbstractInstanceNames = keyof AbstractInstances;\ntype AllAbstractInstances = AbstractInstances[keyof AbstractInstances];\n")),Object(c.b)("h3",{id:"instances"},"Instances"),Object(c.b)("p",null,Object(c.b)("inlineCode",{parentName:"p"},"Instances")," is an interface consisting of a mapping of string name to type for every Roblox instance. It inherits from ",Object(c.b)("inlineCode",{parentName:"p"},"Services"),", ",Object(c.b)("inlineCode",{parentName:"p"},"CreatableInstances"),", and ",Object(c.b)("inlineCode",{parentName:"p"},"AbstractInstances"),". ",Object(c.b)("inlineCode",{parentName:"p"},"Instances")," and also includes any type of Instance which:"),Object(c.b)("ul",null,Object(c.b)("li",{parentName:"ul"},"cannot be created with ",Object(c.b)("inlineCode",{parentName:"li"},'Instance.new("ClassName")')),Object(c.b)("li",{parentName:"ul"},"cannot be fetched with ",Object(c.b)("inlineCode",{parentName:"li"},'game:GetService("ServiceName")')),Object(c.b)("li",{parentName:"ul"},"but ",Object(c.b)("em",{parentName:"li"},"can")," be given a reference to")),Object(c.b)("p",null,"Examples:"),Object(c.b)("ul",null,Object(c.b)("li",{parentName:"ul"},Object(c.b)("inlineCode",{parentName:"li"},"DataModel")," is a class that cannot be created or fetched with GetService, but is given by the ",Object(c.b)("inlineCode",{parentName:"li"},"game")," global value"),Object(c.b)("li",{parentName:"ul"},Object(c.b)("inlineCode",{parentName:"li"},"AnimationTrack")," can only be given a reference to via ",Object(c.b)("inlineCode",{parentName:"li"},":LoadAnimation()")," from ",Object(c.b)("inlineCode",{parentName:"li"},"Humanoid")," or ",Object(c.b)("inlineCode",{parentName:"li"},"AnimationTrack"))),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"interface Instances extends Services, CreatableInstances, AbstractInstances {\n    AnimationTrack: AnimationTrack;\n    BaseWrap: BaseWrap;\n    CatalogPages: CatalogPages;\n    DataModel: DataModel;\n    // ... many more instances!\n}\n")),Object(c.b)("p",null,"You can get a union of all instance names with ",Object(c.b)("inlineCode",{parentName:"p"},"keyof Instances"),".\nAnd you can get a union of all instance types with ",Object(c.b)("inlineCode",{parentName:"p"},"Instances[keyof Instances]"),"."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"type AllInstanceNames = keyof Instances;\ntype AllInstances = Instances[keyof Instances];\n")),Object(c.b)("h3",{id:"usage-with-generics"},"Usage with Generics"),Object(c.b)("p",null,"You can use any of these utility interfaces with generic functions. This is useful for taking an argument string and returning a matching instance type."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { Workspace } from "@rbxts/services";\n\nfunction getDescendantsWhichIsA<T extends keyof Instances>(parent: Instance, className: T): Instances[T][] {\n    return parent.GetDescendants().filter((descendant): descendant is Instances[T] => descendant.IsA(className));\n}\n\nconst humanoidsInWorkspace: Array<Humanoid> = getDescendantsWhichIsA(Workspace, "Humanoid");\n')))}b.isMDXComponent=!0},93:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return m}));var a=t(0),r=t.n(a);function c(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){c(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},c=Object.keys(e);for(a=0;a<c.length;a++)t=c[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(a=0;a<c.length;a++)t=c[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var o=r.a.createContext({}),b=function(e){var n=r.a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=b(e.components);return r.a.createElement(o.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},d=r.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,c=e.originalType,i=e.parentName,o=l(e,["components","mdxType","originalType","parentName"]),p=b(t),d=a,m=p["".concat(i,".").concat(d)]||p[d]||u[d]||c;return t?r.a.createElement(m,s(s({ref:n},o),{},{components:t})):r.a.createElement(m,s({ref:n},o))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var c=t.length,i=new Array(c);i[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var o=2;o<c;o++)i[o]=t[o];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"}}]);