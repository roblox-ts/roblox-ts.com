"use strict";(self.webpackChunkroblox_ts=self.webpackChunkroblox_ts||[]).push([[912],{1788:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var l=n(7624),r=n(2172);const s={title:"LuaTuple<T>"},i=void 0,o={id:"guides/lua-tuple",title:"LuaTuple<T>",description:"The Problem",source:"@site/docs/guides/lua-tuple.mdx",sourceDirName:"guides",slug:"/guides/lua-tuple",permalink:"/docs/guides/lua-tuple",draft:!1,unlisted:!1,editUrl:"https://github.com/roblox-ts/roblox-ts.com/blob/master/docs/guides/lua-tuple.mdx",tags:[],version:"current",frontMatter:{title:"LuaTuple<T>"},sidebar:"docs",previous:{title:"Indexing Children",permalink:"/docs/guides/indexing-children"},next:{title:"Roact JSX",permalink:"/docs/guides/roact-jsx"}},a={},c=[{value:"The Problem",id:"the-problem",level:2},{value:"The Solution",id:"the-solution",level:2},{value:"Examples",id:"examples",level:2},{value:"Using <code>LuaTuple&lt;T&gt;</code> in Your Own Code",id:"using-luatuplet-in-your-own-code",level:2}];function u(e){const t={a:"a",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,r.M)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(t.h2,{id:"the-problem",children:"The Problem"}),"\n",(0,l.jsx)(t.p,{children:"Given the following Luau code, how do we type it?"}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-lua",children:'local function foo()\n\treturn "abc", 123\nend\n'})}),"\n",(0,l.jsxs)(t.p,{children:["Multiple returns are a common occurrence in Luau, but not really a concept in TypeScript. ",(0,l.jsx)(t.a,{href:"https://www.typescriptlang.org/docs/handbook/basic-types.html#tuple",children:'TypeScript does have a feature called "tuples"'})," which allow for fixed length array types with an individual type for each index."]}),"\n",(0,l.jsx)(t.p,{children:"So we might type this as:"}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-ts",children:"declare function foo(): [string, number];\n"})}),"\n",(0,l.jsxs)(t.p,{children:["However, this is not correct! TypeScript tuples are arrays, not multiple returns. It would expect the Luau to be ",(0,l.jsx)(t.code,{children:'return { "abc", 123 }'}),"."]}),"\n",(0,l.jsx)(t.h2,{id:"the-solution",children:"The Solution"}),"\n",(0,l.jsxs)(t.p,{children:["To solve this problem, roblox-ts introduces a special type called ",(0,l.jsx)(t.code,{children:"LuaTuple<T>"}),". This is typed as:"]}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-ts",children:"type LuaTuple<T extends Array<any>> = T & { readonly LUA_TUPLE: never };\n"})}),"\n",(0,l.jsxs)(t.p,{children:[(0,l.jsx)(t.code,{children:"LUA_TUPLE"})," is used to ensure the type name is not lost or cast into an ",(0,l.jsx)(t.code,{children:"Array<T>"})," accidentally."]}),"\n",(0,l.jsx)(t.p,{children:"When the compiler sees this type as a function return type, it can infer that it's meant to be a multiple return."}),"\n",(0,l.jsx)(t.p,{children:"In general, this type is used for typing existing Luau modules or the Roblox API."}),"\n",(0,l.jsx)(t.h2,{id:"examples",children:"Examples"}),"\n",(0,l.jsx)(t.p,{children:"If you immediately destructure the result, it will be compiled into a simple variable declaration from a multiple return."}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-ts",children:"const [actualTimeYielded, totalTime] = wait(1);\n"})}),"\n",(0,l.jsxs)(t.p,{children:["If you do ",(0,l.jsx)(t.em,{children:"not"})," destructure the result, the compiler will wrap the return in ",(0,l.jsx)(t.code,{children:"{ }"})," and turn the result into an array object."]}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-ts",children:"const result = wait(1);\nconst actualTimeYielded = result[0];\nconst totalTime = result[1];\n"})}),"\n",(0,l.jsx)(t.p,{children:"You can also index the result immediately after the function call and receive an optimized emit:"}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-ts",children:'import { Players } from "@rbxts/services";\n\n// .Wait() here returns LuaTuple<[character: Model]>,\n// so we need to use `[0]` to grab the first (and only) element.\nconst character = Players.LocalPlayer.Character || Players.LocalPlayer.CharacterAdded.Wait()[0];\n'})}),"\n",(0,l.jsxs)(t.h2,{id:"using-luatuplet-in-your-own-code",children:["Using ",(0,l.jsx)(t.code,{children:"LuaTuple<T>"})," in Your Own Code"]}),"\n",(0,l.jsxs)(t.p,{children:["The compiler supports using ",(0,l.jsx)(t.code,{children:"LuaTuple<T>"})," in outside of type definitions, but it's generally not recommended. However, if you're writing code that is consumed by an existing Luau module this can be useful!"]}),"\n",(0,l.jsxs)(t.p,{children:["Fortunately, we have a macro called ",(0,l.jsx)(t.code,{children:"$tuple"})," that covers multiple returns so that you don't need to type assert the function return yourself every time you want it to be a tuple."]}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-ts",children:'function hasMultipleReturns() {\n\t// this will compile into `return "abc", 123`\n\treturn $tuple("abc", 123);\n}\n'})})]})}function d(e={}){const{wrapper:t}={...(0,r.M)(),...e.components};return t?(0,l.jsx)(t,{...e,children:(0,l.jsx)(u,{...e})}):u(e)}},2172:(e,t,n)=>{n.d(t,{I:()=>o,M:()=>i});var l=n(1504);const r={},s=l.createContext(r);function i(e){const t=l.useContext(s);return l.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),l.createElement(s.Provider,{value:t},e.children)}}}]);